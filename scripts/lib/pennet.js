// Generated by CoffeeScript 2.5.1
(function() {
  /*
  	Pennet application
  	Autor: Tsvikevich Denis 2019
  */
  var Counter, checkGenotype, checkGenotypes, clearError, combineGametes, createOutput, createPhenotypeInput, evalPhenotype, fail, makeGametes, mergeStrings, onChangeText, runApplication;

  //: import flexibel.coffee
  Counter = class Counter {
    constructor() {
      this.counter = new Map();
    }

    count(element) {
      return countIt(this.counter, element);
    }

    getSize() {
      return this.counter.size;
    }

    getTable(tableName) {
      var builder;
      return builder = `<label>${tableName}: </label><br>
<table class="table table-bordered">
	<tr>${ejoin(makeKeyCells(this.counter))}</tr>
	<tr>${ejoin(makeValueCells(this.counter))}</tr>
</table>`;
    }

  };

  runApplication = function() {
    var gametesFirst, gametesSecond, genotype1, genotype2;
    clearError();
    genotype1 = valueof("genotype1").trim();
    genotype2 = valueof("genotype2").trim();
    if (!checkGenotypes(genotype1, genotype2)) {
      return;
    }
    gametesFirst = makeGametes(genotype1);
    gametesSecond = genotype1 === genotype2 ? gametesFirst : makeGametes(genotype2);
    return htmlset("tableplace", createOutput(gametesFirst, gametesSecond));
  };

  fail = function(error) {
    htmlset("errorlogs", `<p style="color: red;">${error}</p>`);
    return false;
  };

  clearError = function() {
    return fail("");
  };

  createOutput = function(g1, g2) {
    var builder, genotype, genotypeCounter, i, j, k, l, len, len1, len2, m, phenotype, phenotypeCounter, subbuilder;
    genotypeCounter = new Counter();
    phenotypeCounter = new Counter();
    builder = `<br><label>Решётка Пеннета: </label><br>
<table class="table table-bordered"><tr><td></td>`;
    for (k = 0, len = g2.length; k < len; k++) {
      i = g2[k];
      builder += `<td>${i}</td>`;
    }
    builder += "</tr>";
    for (l = 0, len1 = g1.length; l < len1; l++) {
      i = g1[l];
      builder += `<tr><td>${i}</td>`;
      for (m = 0, len2 = g2.length; m < len2; m++) {
        j = g2[m];
        genotype = combineGametes(i, j);
        if (genotype === null) {
          return "";
        }
        phenotype = evalPhenotype(genotype);
        genotypeCounter.count(genotype);
        phenotypeCounter.count(phenotype);
        builder += phenotype !== null ? `<td>${genotype}<br>(${phenotype})</td>` : `<td>${genotype}</td>`;
      }
      builder += "</tr>";
    }
    subbuilder = genotypeCounter.getTable("Расщепление по генотипу");
    if (phenotypeCounter.getSize() > 1) {
      subbuilder += "<br>" + phenotypeCounter.getTable("Расщепление по фенотипу");
    }
    return builder + `</table><br><div>${subbuilder}</div>`;
  };

  evalPhenotype = function(genotype) {
    var allel, k, len, phenotypeParts, val;
    phenotypeParts = new Map();
    for (k = 0, len = genotype.length; k < len; k++) {
      allel = genotype[k];
      val = valueof("inputFor" + allel);
      if (val === "") {
        continue;
      }
      if (allel.toUpperCase() === allel) {
        phenotypeParts.set(allel, val);
      }
      if (!phenotypeParts.has(allel.toUpperCase())) {
        phenotypeParts.set(allel, val);
      }
    }
    if (!phenotypeParts.size) {
      return null;
    }
    return values(phenotypeParts).join(", ");
  };

  combineGametes = function(g1, g2) {
    var i;
    if (g1.length !== g2.length) {
      return fail("wrong gamet length");
    }
    return ejoin((function() {
      var k, ref, results;
      results = [];
      for (i = k = 0, ref = g1.length; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
        results.push(g1[i] < g2[i] ? g1[i] + g2[i] : g2[i] + g1[i]);
      }
      return results;
    })());
  };

  // Создаёт набор гамет для заданного генотипа
  makeGametes = function(genotype) {
    var helper;
    helper = function(genotype, position) {
      var gams;
      if (position >= genotype.length) { // если аллелей не осталось - undefined
        return;
      }
      gams = helper(genotype, position + 2);
      if (gams === void 0) {
        // если перебрали всё - удаляем повторяющиеся элементы
        return unique([genotype[position], genotype[position + 1]]);
      }
      if (genotype[position] === genotype[position + 1]) {
        return gams.map(function(i) {
          return genotype[position] + i;
        });
      } else {
        return [
          ...gams.map(function(i) {
            return genotype[position] + i;
          }),
          ...gams.map(function(i) {
            return genotype[position + 1] + i;
          })
        ];
      }
    };
    return helper(genotype, 0);
  };

  onChangeText = function() {
    var allel, alleles, gametes;
    clearError();
    htmlset("gametparams", "");
    if (!checkGenotypes(valueof("genotype1"), valueof("genotype2"))) {
      return;
    }
    gametes = makeGametes(valueof("genotype1"));
    if (gametes === null) {
      return;
    }
    alleles = mergeStrings(gametes[0].toUpperCase(), gametes[0].toLowerCase());
    return htmlset("gametparams", ((function() {
      var k, len, results;
      results = [];
      for (k = 0, len = alleles.length; k < len; k++) {
        allel = alleles[k];
        results.push(createPhenotypeInput(allel));
      }
      return results;
    })()).join(""));
  };

  createPhenotypeInput = function(allel) {
    return `<div class="input-control">
	<label for="inputFor${allel}">Фенотип ${allel}</label>
	<input type="text" class="form-control" id="inputFor${allel}">
</div>`;
  };

  checkGenotype = function(genotype) {
    var msg;
    msg = `Введён некорректный генотип ${genotype}`;
    if (genotype.length % 2 !== 0) { // поддерживаются только аллели кратные двум
      return fail(msg);
    }
    return true;
  };

  checkGenotypes = function(genotype1, genotype2) {
    var i, k, msg, ref;
    if (!checkGenotype(genotype1 || checkGenotype(genotype2))) {
      return false;
    }
    msg = `Генотипы ${genotype1} и ${genotype2} некорректны`;
    if (genotype1.length !== genotype2.length) { // число аллелей должно быть одинаковым
      return fail(msg);
    }
// порядок аллелей должен быть одинаковым
    for (i = k = 0, ref = genotype1.length; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
      if (genotype1[i].toLowerCase() !== genotype2[i].toLowerCase()) {
        return fail(msg);
      }
    }
    return true;
  };

  mergeStrings = function(string1, string2) {
    var i;
    return ((function() {
      var k, ref, results;
      results = [];
      for (i = k = 0, ref = string1.length; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
        results.push(string1[i] + string2[i]);
      }
      return results;
    })()).join("");
  };

  element("genotype1").addEventListener("input", onChangeText);

  element("genotype2").addEventListener("input", onChangeText);

  element("runButton").addEventListener("click", runApplication);

}).call(this);
