// Generated by CoffeeScript 2.5.1
(function() {
  /*
  	Complementarity application
  	Autor: Tsvikevich Denis 2019
  */
  var DNA_COMPLIMENTARITY_SCHEME, DNA_VALID_CHARS, GENETIC_CODE, INPUT_TYPE, RNA_COMPLIMENTARITY_SCHEME, RNA_VALID_CHARS, all, any, buildByDnaOne, buildByDnaTwo, buildByInformationalRna, buildByProtein, buildByTransferRna, checkedof, clearError, countIt, delws, div, ejoin, element, first, formatOutput, formatProteinSequence, getCheckerAndInputElement, h1, h2, h3, h4, h5, h6, htmlget, htmlset, isValidAminoacid, isValidDnaChar, isValidRnaChar, keys, last, lastInputType, logError, makeComplimentaryDna, makeDnaFromiRna, makeInformationalRna, makeInformationalRnaFromProtein, makeKeyCells, makeMapCells, makeProteinFromInformationalRna, makeTransferRna, makeValueCells, mapString, max, maxKey, maxValue, min, mul, neue, neueText, runApplication, runButton, runParser, setLastInputType, sub, sum, uniformNucleotide, uniformSequence, unique, updateFields, validateInput, valueof, values, valueset,
    indexOf = [].indexOf;

  // Operator function for '-'
  sub = function(x, y) {
    return x - y;
  };

  // Operator function for '+', also allow to sum of array
  sum = function(x, y) {
    if (y == null) {
      return x.reduce(document.flexibel.sum);
    }
    return x + y;
  };

  // Operator function for '*', also allow to mul of array
  mul = function(x, y) {
    if (y == null) {
      return x.reduce(document.flexibel.mul);
    }
    return x * y;
  };

  // Operator function for '/'
  div = function(x, y) {
    return x / y;
  };

  // Returns the min of two elements, or min of array
  min = function(x, y) {
    if (y == null) {
      return x.reduce(document.flexibel.min);
    }
    if (x < y) {
      return x;
    } else {
      return y;
    }
  };

  // Returns the max of two elements, or max of array
  max = function(x, y) {
    if (y == null) {
      return x.reduce(document.flexibel.max);
    }
    if (x > y) {
      return x;
    } else {
      return y;
    }
  };

  last = function(container) {
    return container[container.length - 1];
  };

  first = function(container) {
    return container[0];
  };

  neue = function(name, inner) {
    var elem;
    elem = document.createElement(name);
    if (inner != null) {
      elem.innerHTML = inner;
    }
    return elem;
  };

  neueText = function(name, inner) {
    var elem;
    elem = document.createElement(name);
    if (inner != null) {
      elem.innerText = inner;
    }
    return elem;
  };

  div = function(inner) {
    var elem;
    elem = document.createElement("div");
    if (inner != null) {
      elem.innerHTML = inner;
    }
    return elem;
  };

  h1 = function(text) {
    return neueText("h1", text);
  };

  h2 = function(text) {
    return neueText("h2", text);
  };

  h3 = function(text) {
    return neueText("h3", text);
  };

  h4 = function(text) {
    return neueText("h4", text);
  };

  h5 = function(text) {
    return neueText("h5", text);
  };

  h6 = function(text) {
    return neueText("h6", text);
  };

  element = function(id) {
    if (id.startsWith(".")) {
      return document.getElementsByClassName(id.substring(1));
    }
    return document.getElementById(id);
  };

  valueset = function(id, value) {
    return document.flexibel.element(id).value = value;
  };

  valueof = function(id) {
    return document.flexibel.element(id).value;
  };

  checkedof = function(id) {
    return document.flexibel.element(id).checked;
  };

  htmlset = function(id, html) {
    return document.flexibel.element(id).innerHTML = html;
  };

  htmlget = function(id) {
    return document.flexibel.element(id).innerHTML;
  };

  any = function(values, f) {
    var i, j, len;
    for (j = 0, len = values.length; j < len; j++) {
      i = values[j];
      if (f(i)) {
        return true;
      }
    }
    return false;
  };

  all = function(values, f) {
    var i, j, len;
    for (j = 0, len = values.length; j < len; j++) {
      i = values[j];
      if (!f(i)) {
        return false;
      }
    }
    return true;
  };

  ejoin = function(values) {
    return values.join("");
  };

  delws = function(str, sym) {
    return str.replace(/\s+/g, "");
  };

  values = function(map) {
    return [...map.values()];
  };

  keys = function(map) {
    return [...map.keys()];
  };

  maxKey = function(map) {
    return document.flexibel.keys(map).reduce(document.flexibel.max);
  };

  maxValue = function(map) {
    return document.flexibel.values(map).reduce(document.flexibel.max);
  };

  unique = function(values) {
    return [...new Set(values)];
  };

  countIt = function(map, it) {
    if (map.has(it)) {
      return map.set(it, map.get(it) + 1);
    } else {
      return map.set(it, 1);
    }
  };

  makeValueCells = function(map) {
    var ref, results, v;
    ref = map.values();
    results = [];
    for (v of ref) {
      results.push(`<td>${v}</td>`);
    }
    return results;
  };

  makeKeyCells = function(map) {
    var k, ref, results;
    ref = map.keys();
    results = [];
    for (k of ref) {
      results.push(`<td>${k}</td>`);
    }
    return results;
  };

  makeMapCells = function(values, mapper) {
    var k, results;
    results = [];
    for (k of values) {
      results.push(`<td>${mapper(k)}</td>`);
    }
    return results;
  };

  document.flexibel = {makeKeyCells, makeValueCells, countIt, maxValue, maxKey, keys, values, delws, ejoin, htmlset, checkedof, valueof, valueset, element, first, last, max, min, sum, sub, mul, div, all, any};

  runParser = function(input) {
    var getCurrent, next, parseNumber, parserState, ref;
    parserState = {
      result: [],
      currentPosition: 0,
      input: input
    };
    getCurrent = function(state) {
      return state.input[state.currentPosition];
    };
    next = function(state) {
      var current;
      current = getCurrent(state);
      state.currentPosition++;
      return current;
    };
    parseNumber = function(state) {
      var buffer, current, ref;
      buffer = next(state);
      while (ref = (current = next(state)), indexOf.call("0123456789.", ref) >= 0) {
        buffer += current;
      }
      return state.result.push(parseFloat(buffer));
    };
    while (parserState.currentPosition < input.length) {
      if (ref = getCurrent(parserState), indexOf.call("0123456789-", ref) >= 0) {
        parseNumber(parserState);
      } else {
        next(parserState);
      }
    }
    return parserState.result;
  };

  DNA_VALID_CHARS = "ATGCatgcАТГЦатгц ";

  RNA_VALID_CHARS = "AUGCaugcАУГЦаугц ";

  DNA_COMPLIMENTARITY_SCHEME = new Map([["А", "Т"], ["Т", "А"], ["Г", "Ц"], ["У", "А"], ["Ц", "Г"]]);

  RNA_COMPLIMENTARITY_SCHEME = new Map([["А", "У"], ["Т", "А"], ["У", "А"], ["Г", "Ц"], ["Ц", "Г"]]);

  GENETIC_CODE = new Map([["УУУ", "ФЕН"], ["УУЦ", "ФЕН"], ["УУА", "ЛЕЙ"], ["УЦУ", "СЕР"], ["УЦЦ", "СЕР"], ["УЦА", "СЕР"], ["УЦГ", "СЕР"], ["УАУ", "ТИР"], ["УАЦ", "ТИР"], ["УАА", "СТОП"], ["УАГ", "СТОП"], ["УГУ", "ЦИС"], ["УГЦ", "ЦИС"], ["УГА", "СТОП"], ["УГГ", "ТРИ"], ["ЦУУ", "ЛЕЙ"], ["ЦУЦ", "ЛЕЙ"], ["ЦУА", "ЛЕЙ"], ["ЦУГ", "ЛЕЙ"], ["ЦЦУ", "ПРО"], ["ЦЦЦ", "ПРО"], ["ЦЦА", "ПРО"], ["ЦЦГ", "ПРО"], ["ЦАУ", "ГИС"], ["ЦАЦ", "ГИС"], ["ЦАА", "ГЛУ"], ["ЦАГ", "ГЛУ"], ["ЦГУ", "АРГ"], ["ЦГЦ", "АРГ"], ["ЦГА", "АРГ"], ["ЦГГ", "АРГ"], ["АУУ", "ИЛЕ"], ["АУЦ", "ИЛЕ"], ["АУА", "ИЛЕ"], ["АУГ", "МЕТ"], ["ГУУ", "ВАЛ"], ["ГУЦ", "ВАЛ"], ["ГУА", "ВАЛ"], ["ГУГ", "ВАЛ"], ["АЦУ", "ТРЕ"], ["АЦЦ", "ТРЕ"], ["АЦА", "ТРЕ"], ["АЦГ", "ТРЕ"], ["ГЦУ", "АЛА"], ["ГЦЦ", "АЛА"], ["ГЦА", "АЛА"], ["ГЦГ", "АЛА"], ["ААУ", "АСН"], ["ААЦ", "АСН"], ["ААА", "ЛИЗ"], ["ААГ", "ЛИЗ"], ["ГАУ", "АСП"], ["ГАЦ", "АСП"], ["ГАА", "ГЛУ"], ["ГАГ", "ГЛУ"], ["АГУ", "СЕР"], ["АГЦ", "СЕР"], ["АГА", "АРГ"], ["АГГ", "АРГ"], ["ГГУ", "ГЛИ"], ["ГГЦ", "ГЛИ"], ["ГГА", "ГЛИ"], ["ГГГ", "ГЛИ"]]);

  INPUT_TYPE = {
    DNA1: 1,
    DNA2: 2,
    IRNA: 3,
    TRNA: 4,
    PROTEIN: 5
  };

  runButton = document.getElementById("runButton");

  lastInputType = {
    inputType: 1
  };

  setLastInputType = function(inputType) {
    lastInputType.inputType = inputType;
    return runButton.innerText = "Построить по " + (function() {
      switch (inputType) {
        case INPUT_TYPE.DNA1:
          return "ДНК 1";
        case INPUT_TYPE.DNA2:
          return "ДНК 2";
        case INPUT_TYPE.IRNA:
          return "иРНК";
        case INPUT_TYPE.TRNA:
          return "тРНК";
        case INPUT_TYPE.PROTEIN:
          return "белку";
      }
    })();
  };

  updateFields = function(result) {
    valueset("dnaInput", formatOutput(result.firstDna));
    valueset("dna2Input", formatOutput(result.secondDna));
    valueset("irnaInput", formatOutput(result.informationalRna));
    valueset("trnaInput", formatOutput(result.transferRna));
    return valueset("proteinInput", result.protein);
  };

  runApplication = function() {
    var result;
    result = (function() {
      switch (lastInputType.inputType) {
        case INPUT_TYPE.DNA1:
          return buildByDnaOne();
        case INPUT_TYPE.DNA2:
          return buildByDnaTwo();
        case INPUT_TYPE.IRNA:
          return buildByInformationalRna();
        case INPUT_TYPE.TRNA:
          return buildByTransferRna();
        case INPUT_TYPE.PROTEIN:
          return buildByProtein();
      }
    })();
    return updateFields(result);
  };

  buildByDnaOne = function() {
    var firstDna, informationalRna, protein, secondDna, transferRna;
    firstDna = uniformSequence(valueof("dnaInput"));
    secondDna = makeComplimentaryDna(firstDna);
    informationalRna = makeInformationalRna(firstDna);
    transferRna = makeTransferRna(informationalRna);
    protein = makeProteinFromInformationalRna(informationalRna);
    return {firstDna, secondDna, informationalRna, transferRna, protein};
  };

  buildByDnaTwo = function() {
    var firstDna, informationalRna, protein, secondDna, transferRna;
    secondDna = uniformSequence(valueof("dna2Input"));
    firstDna = makeComplimentaryDna(secondDna);
    informationalRna = makeInformationalRna(firstDna);
    transferRna = makeTransferRna(informationalRna);
    protein = makeProteinFromInformationalRna(informationalRna);
    return {firstDna, secondDna, informationalRna, transferRna, protein};
  };

  buildByInformationalRna = function() {
    var firstDna, informationalRna, protein, secondDna, transferRna;
    informationalRna = uniformSequence(valueof("irnaInput"));
    firstDna = makeDnaFromiRna(informationalRna);
    secondDna = makeComplimentaryDna(firstDna);
    transferRna = makeTransferRna(informationalRna);
    protein = makeProteinFromInformationalRna(informationalRna);
    return {firstDna, secondDna, informationalRna, transferRna, protein};
  };

  buildByTransferRna = function() {
    var firstDna, informationalRna, protein, secondDna, transferRna;
    transferRna = uniformSequence(valueof("trnaInput"));
    secondDna = makeDnaFromiRna(transferRna);
    firstDna = makeComplimentaryDna(secondDna);
    informationalRna = makeInformationalRna(firstDna);
    protein = makeProteinFromInformationalRna(informationalRna);
    return {firstDna, secondDna, informationalRna, transferRna, protein};
  };

  buildByProtein = function() {
    var firstDna, informationalRna, protein, secondDna, transferRna;
    protein = valueof("proteinInput");
    informationalRna = makeInformationalRnaFromProtein(protein);
    firstDna = makeDnaFromiRna(informationalRna);
    secondDna = makeComplimentaryDna(firstDna);
    transferRna = makeTransferRna(informationalRna);
    return {firstDna, secondDna, informationalRna, transferRna, protein};
  };

  makeProteinFromInformationalRna = function(irna) {
    var divideIntoTriplets;
    divideIntoTriplets = function(irna) {
      var currentTriplet, i, index, j, len, triplets;
      triplets = [];
      currentTriplet = "";
      index = 0;
      for (j = 0, len = irna.length; j < len; j++) {
        i = irna[j];
        currentTriplet += i;
        index++;
        if (index === 3) {
          triplets.push(currentTriplet);
          currentTriplet = "";
          index = 0;
        }
      }
      return triplets;
    };
    return divideIntoTriplets(irna).map(function(x) {
      return GENETIC_CODE.get(x);
    }).join("-");
  };

  makeInformationalRnaFromProtein = function(protein) {
    var aminoacid, i, j, len, ref, result;
    result = "";
    ref = protein.split("-");
    for (j = 0, len = ref.length; j < len; j++) {
      aminoacid = ref[j];
      for (i of GENETIC_CODE) {
        if (i[1] === aminoacid) {
          result += i[0];
          break;
        }
      }
    }
    return result;
  };

  mapString = function(string, mapper) {
    var char;
    return ((function() {
      var j, len, results;
      results = [];
      for (j = 0, len = string.length; j < len; j++) {
        char = string[j];
        results.push(mapper(char));
      }
      return results;
    })()).join("");
  };

  makeComplimentaryDna = function(dna) {
    return mapString(dna, function(x) {
      return DNA_COMPLIMENTARITY_SCHEME.get(x);
    });
  };

  makeInformationalRna = function(dna1) {
    return mapString(dna1, function(x) {
      return RNA_COMPLIMENTARITY_SCHEME.get(x);
    });
  };

  makeDnaFromiRna = function(irna) {
    return mapString(irna, function(x) {
      return DNA_COMPLIMENTARITY_SCHEME.get(x);
    });
  };

  makeTransferRna = function(irna) {
    return mapString(irna, function(x) {
      return RNA_COMPLIMENTARITY_SCHEME.get(x);
    });
  };

  uniformSequence = function(dna) {
    return mapString(delws(dna), uniformNucleotide);
  };

  uniformNucleotide = function(nucleotide) {
    switch (nucleotide.toUpperCase()) {
      case "A":
        return "А";
      case "T":
        return "Т";
      case "G":
        return "Г";
      case "C":
        return "Ц";
      case "U":
        return "У";
      default:
        return nucleotide.toUpperCase();
    }
  };

  validateInput = function(type) {
    var aminoacid, checker, formatedInput, i, inputElement, j, l, len, len1, ref, ref1;
    setLastInputType(type);
    clearError();
    if (type === INPUT_TYPE.PROTEIN) {
      formatedInput = formatProteinSequence(valueof("proteinInput").replace(/\-/g, ''));
      ref = formatedInput.split("-");
      for (j = 0, len = ref.length; j < len; j++) {
        aminoacid = ref[j];
        if (!isValidAminoacid(aminoacid)) {
          return logError(`Ошибка: неизвестная аминокислота '${aminoacid}'`, type);
        }
      }
      return document.mainForm.proteinInput.value = formatedInput;
    } else {
      ({checker, inputElement} = getCheckerAndInputElement(type));
      ref1 = inputElement.value;
      for (l = 0, len1 = ref1.length; l < len1; l++) {
        i = ref1[l];
        if (!checker(i)) {
          return logError(`Ошибка: неожиданный символ '${i}'`, type);
        }
      }
      inputElement.value = formatOutput(delws(inputElement.value));
      if (uniformSequence(inputElement.value).length % 3 !== 0) {
        return logError("Ошибка: неполный триплет", type);
      }
    }
  };

  getCheckerAndInputElement = function(inputType) {
    switch (inputType) {
      case INPUT_TYPE.DNA1:
        return {
          checker: isValidDnaChar,
          inputElement: element("dnaInput")
        };
      case INPUT_TYPE.DNA2:
        return {
          checker: isValidDnaChar,
          inputElement: element("dna2Input")
        };
      case INPUT_TYPE.IRNA:
        return {
          checker: isValidRnaChar,
          inputElement: element("irnaInput")
        };
      case INPUT_TYPE.TRNA:
        return {
          checker: isValidRnaChar,
          inputElement: element("trnaInput")
        };
      default:
        return {
          checker: isValidDnaChar,
          inputElement: element("dnaInput")
        };
    }
  };

  isValidAminoacid = function(aminoacid) {
    var isPart, normalizedAminoacid, ref, v;
    if (aminoacid.length === 0) {
      return true;
    }
    normalizedAminoacid = aminoacid.toUpperCase();
    ref = GENETIC_CODE.values();
    for (v of ref) {
      isPart = v.startsWith(normalizedAminoacid);
      if (isPart) {
        break;
      }
    }
    return isPart;
  };

  isValidDnaChar = function(char) {
    return indexOf.call(DNA_VALID_CHARS, char) >= 0;
  };

  isValidRnaChar = function(char) {
    return indexOf.call(RNA_VALID_CHARS, char) >= 0;
  };

  logError = function(message, inputType) {
    var logger;
    logger = (function() {
      switch (inputType) {
        case INPUT_TYPE.DNA1:
          return element("dna1err");
        case INPUT_TYPE.DNA2:
          return element("dna2err");
        case INPUT_TYPE.IRNA:
          return element("irnaerr");
        case INPUT_TYPE.TRNA:
          return element("trnaerr");
        case INPUT_TYPE.PROTEIN:
          return element("proteinerr");
      }
    })();
    return logger.innerHTML = message;
  };

  clearError = function() {
    var i, j, results;
    results = [];
    for (i = j = 1; j <= 5; i = ++j) {
      results.push(logError("", i));
    }
    return results;
  };

  formatOutput = function(sequence) {
    var currentTriplet, i, index, j, len, ref, triplets;
    triplets = [];
    currentTriplet = "";
    index = 0;
    ref = uniformSequence(sequence);
    for (j = 0, len = ref.length; j < len; j++) {
      i = ref[j];
      currentTriplet += i;
      index++;
      if (index === 3) {
        triplets.push(currentTriplet);
        currentTriplet = "";
        index = 0;
      }
    }
    if (currentTriplet.length > 0) {
      triplets.push(currentTriplet);
    }
    return triplets.join(" ");
  };

  formatProteinSequence = function(sequence) {
    var currentTriplet, i, index, j, len, ref, triplets;
    triplets = [];
    currentTriplet = "";
    index = 0;
    ref = sequence.toUpperCase();
    for (j = 0, len = ref.length; j < len; j++) {
      i = ref[j];
      currentTriplet += i;
      index++;
      if ((index === 3 && currentTriplet !== "СТО") || (index === 4)) {
        triplets.push(currentTriplet);
        currentTriplet = "";
        index = 0;
      }
    }
    if (currentTriplet.length > 0) {
      triplets.push(currentTriplet);
    }
    return triplets.join("-");
  };

  document.getElementById("dnaInput").addEventListener("input", function() {
    return validateInput(INPUT_TYPE.DNA1);
  });

  document.getElementById("dna2Input").addEventListener("input", function() {
    return validateInput(INPUT_TYPE.DNA2);
  });

  document.getElementById("irnaInput").addEventListener("input", function() {
    return validateInput(INPUT_TYPE.IRNA);
  });

  document.getElementById("trnaInput").addEventListener("input", function() {
    return validateInput(INPUT_TYPE.TRNA);
  });

  document.getElementById("proteinInput").addEventListener("input", function() {
    return validateInput(INPUT_TYPE.PROTEIN);
  });

  document.getElementById("runButton").addEventListener("click", runApplication);

  document.getElementById("buildByDna1Button").addEventListener("click", function() {
    return updateFields(buildByDnaOne());
  });

  document.getElementById("buildByDna2Button").addEventListener("click", function() {
    return updateFields(buildByDnaTwo());
  });

  document.getElementById("buildByiRnaButton").addEventListener("click", function() {
    return updateFields(buildByInformationalRna());
  });

  document.getElementById("buildBytRnaButton").addEventListener("click", function() {
    return updateFields(buildByTransferRna());
  });

  document.getElementById("buildByProteinButton").addEventListener("click", function() {
    return updateFields(buildByProtein());
  });

}).call(this);
