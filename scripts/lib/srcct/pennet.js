// Generated by CoffeeScript 2.5.1
(function() {
  /*
  	Pennet application
  	Autor: Tsvikevich Denis 2019
  */
  var Counter, all, any, checkGenotype, checkGenotypes, checkedof, clearError, combineGametes, countIt, createOutput, createPhenotypeInput, delws, div, ejoin, element, evalPhenotype, fail, first, h1, h2, h3, h4, h5, h6, htmlget, htmlset, keys, last, makeGametes, makeKeyCells, makeMapCells, makeValueCells, max, maxKey, maxValue, mergeStrings, min, mul, neue, neueText, onChangeText, runApplication, runParser, sub, sum, unique, valueof, values, valueset,
    indexOf = [].indexOf;

  // Operator function for '-'
  sub = function(x, y) {
    return x - y;
  };

  // Operator function for '+', also allow to sum of array
  sum = function(x, y) {
    if (y == null) {
      return x.reduce(document.flexibel.sum);
    }
    return x + y;
  };

  // Operator function for '*', also allow to mul of array
  mul = function(x, y) {
    if (y == null) {
      return x.reduce(document.flexibel.mul);
    }
    return x * y;
  };

  // Operator function for '/'
  div = function(x, y) {
    return x / y;
  };

  // Returns the min of two elements, or min of array
  min = function(x, y) {
    if (y == null) {
      return x.reduce(document.flexibel.min);
    }
    if (x < y) {
      return x;
    } else {
      return y;
    }
  };

  // Returns the max of two elements, or max of array
  max = function(x, y) {
    if (y == null) {
      return x.reduce(document.flexibel.max);
    }
    if (x > y) {
      return x;
    } else {
      return y;
    }
  };

  last = function(container) {
    return container[container.length - 1];
  };

  first = function(container) {
    return container[0];
  };

  neue = function(name, inner) {
    var elem;
    elem = document.createElement(name);
    if (inner != null) {
      elem.innerHTML = inner;
    }
    return elem;
  };

  neueText = function(name, inner) {
    var elem;
    elem = document.createElement(name);
    if (inner != null) {
      elem.innerText = inner;
    }
    return elem;
  };

  div = function(inner) {
    var elem;
    elem = document.createElement("div");
    if (inner != null) {
      elem.innerHTML = inner;
    }
    return elem;
  };

  h1 = function(text) {
    return neueText("h1", text);
  };

  h2 = function(text) {
    return neueText("h2", text);
  };

  h3 = function(text) {
    return neueText("h3", text);
  };

  h4 = function(text) {
    return neueText("h4", text);
  };

  h5 = function(text) {
    return neueText("h5", text);
  };

  h6 = function(text) {
    return neueText("h6", text);
  };

  element = function(id) {
    if (id.startsWith(".")) {
      return document.getElementsByClassName(id.substring(1));
    }
    return document.getElementById(id);
  };

  valueset = function(id, value) {
    return document.flexibel.element(id).value = value;
  };

  valueof = function(id) {
    return document.flexibel.element(id).value;
  };

  checkedof = function(id) {
    return document.flexibel.element(id).checked;
  };

  htmlset = function(id, html) {
    return document.flexibel.element(id).innerHTML = html;
  };

  htmlget = function(id) {
    return document.flexibel.element(id).innerHTML;
  };

  any = function(values, f) {
    var i, l, len;
    for (l = 0, len = values.length; l < len; l++) {
      i = values[l];
      if (f(i)) {
        return true;
      }
    }
    return false;
  };

  all = function(values, f) {
    var i, l, len;
    for (l = 0, len = values.length; l < len; l++) {
      i = values[l];
      if (!f(i)) {
        return false;
      }
    }
    return true;
  };

  ejoin = function(values) {
    return values.join("");
  };

  delws = function(str, sym) {
    return str.replace(/\s+/g, "");
  };

  values = function(map) {
    return [...map.values()];
  };

  keys = function(map) {
    return [...map.keys()];
  };

  maxKey = function(map) {
    return document.flexibel.keys(map).reduce(document.flexibel.max);
  };

  maxValue = function(map) {
    return document.flexibel.values(map).reduce(document.flexibel.max);
  };

  unique = function(values) {
    return [...new Set(values)];
  };

  countIt = function(map, it) {
    if (map.has(it)) {
      return map.set(it, map.get(it) + 1);
    } else {
      return map.set(it, 1);
    }
  };

  makeValueCells = function(map) {
    var ref, results, v;
    ref = map.values();
    results = [];
    for (v of ref) {
      results.push(`<td>${v}</td>`);
    }
    return results;
  };

  makeKeyCells = function(map) {
    var k, ref, results;
    ref = map.keys();
    results = [];
    for (k of ref) {
      results.push(`<td>${k}</td>`);
    }
    return results;
  };

  makeMapCells = function(values, mapper) {
    var k, results;
    results = [];
    for (k of values) {
      results.push(`<td>${mapper(k)}</td>`);
    }
    return results;
  };

  document.flexibel = {makeKeyCells, makeValueCells, countIt, maxValue, maxKey, keys, values, delws, ejoin, htmlset, checkedof, valueof, valueset, element, first, last, max, min, sum, sub, mul, div, all, any};

  runParser = function(input) {
    var getCurrent, next, parseNumber, parserState, ref;
    parserState = {
      result: [],
      currentPosition: 0,
      input: input
    };
    getCurrent = function(state) {
      return state.input[state.currentPosition];
    };
    next = function(state) {
      var current;
      current = getCurrent(state);
      state.currentPosition++;
      return current;
    };
    parseNumber = function(state) {
      var buffer, current, ref;
      buffer = next(state);
      while (ref = (current = next(state)), indexOf.call("0123456789.", ref) >= 0) {
        buffer += current;
      }
      return state.result.push(parseFloat(buffer));
    };
    while (parserState.currentPosition < input.length) {
      if (ref = getCurrent(parserState), indexOf.call("0123456789-", ref) >= 0) {
        parseNumber(parserState);
      } else {
        next(parserState);
      }
    }
    return parserState.result;
  };

  Counter = class Counter {
    constructor() {
      this.counter = new Map();
    }

    count(element) {
      return countIt(this.counter, element);
    }

    getSize() {
      return this.counter.size;
    }

    getTable(tableName) {
      var builder;
      return builder = `<label class="small">${tableName}: </label><br>
<table class="table table-bordered">
	<tr>${ejoin(makeKeyCells(this.counter))}</tr>
	<tr>${ejoin(makeValueCells(this.counter))}</tr>
</table>`;
    }

  };

  runApplication = function() {
    var gametesFirst, gametesSecond, genotype1, genotype2;
    clearError();
    genotype1 = valueof("genotype1").trim();
    genotype2 = valueof("genotype2").trim();
    if (!checkGenotypes(genotype1, genotype2)) {
      return;
    }
    gametesFirst = makeGametes(genotype1);
    gametesSecond = genotype1 === genotype2 ? gametesFirst : makeGametes(genotype2);
    return htmlset("tableplace", createOutput(gametesFirst, gametesSecond));
  };

  fail = function(error) {
    htmlset("errorlogs", `<p style="color: red;">${error}</p>`);
    return false;
  };

  clearError = function() {
    return fail("");
  };

  createOutput = function(g1, g2) {
    var builder, genotype, genotypeCounter, i, j, l, len, len1, len2, m, n, phenotype, phenotypeCounter, subbuilder;
    genotypeCounter = new Counter();
    phenotypeCounter = new Counter();
    builder = `<br><label class="small">Решётка Пеннета: </label><br>
<table class="table table-bordered"><tr><td></td>`;
    for (l = 0, len = g2.length; l < len; l++) {
      i = g2[l];
      builder += `<td>${i}</td>`;
    }
    builder += "</tr>";
    for (m = 0, len1 = g1.length; m < len1; m++) {
      i = g1[m];
      builder += `<tr><td>${i}</td>`;
      for (n = 0, len2 = g2.length; n < len2; n++) {
        j = g2[n];
        genotype = combineGametes(i, j);
        if (genotype === null) {
          return "";
        }
        phenotype = evalPhenotype(genotype);
        genotypeCounter.count(genotype);
        phenotypeCounter.count(phenotype);
        builder += phenotype !== null ? `<td>${genotype}<br>(${phenotype})</td>` : `<td>${genotype}</td>`;
      }
      builder += "</tr>";
    }
    subbuilder = genotypeCounter.getTable("Расщепление по генотипу");
    if (phenotypeCounter.getSize() > 1) {
      subbuilder += "<br>" + phenotypeCounter.getTable("Расщепление по фенотипу");
    }
    return builder + `</table><br><div>${subbuilder}</div>`;
  };

  evalPhenotype = function(genotype) {
    var allel, l, len, phenotypeParts, val;
    phenotypeParts = new Map();
    for (l = 0, len = genotype.length; l < len; l++) {
      allel = genotype[l];
      val = valueof("inputFor" + allel);
      if (val === "") {
        continue;
      }
      if (allel.toUpperCase() === allel) {
        phenotypeParts.set(allel, val);
      }
      if (!phenotypeParts.has(allel.toUpperCase())) {
        phenotypeParts.set(allel, val);
      }
    }
    if (!phenotypeParts.size) {
      return null;
    }
    return values(phenotypeParts).join(", ");
  };

  combineGametes = function(g1, g2) {
    var i;
    if (g1.length !== g2.length) {
      return fail("wrong gamet length");
    }
    return ejoin((function() {
      var l, ref, results;
      results = [];
      for (i = l = 0, ref = g1.length; (0 <= ref ? l < ref : l > ref); i = 0 <= ref ? ++l : --l) {
        results.push(g1[i] < g2[i] ? g1[i] + g2[i] : g2[i] + g1[i]);
      }
      return results;
    })());
  };

  // Создаёт набор гамет для заданного генотипа
  makeGametes = function(genotype) {
    var helper;
    helper = function(genotype, position) {
      var gams;
      if (position >= genotype.length) { // если аллелей не осталось - undefined
        return;
      }
      gams = helper(genotype, position + 2);
      if (gams === void 0) {
        // если перебрали всё - удаляем повторяющиеся элементы
        return unique([genotype[position], genotype[position + 1]]);
      }
      if (genotype[position] === genotype[position + 1]) {
        return gams.map(function(i) {
          return genotype[position] + i;
        });
      } else {
        return [
          ...gams.map(function(i) {
            return genotype[position] + i;
          }),
          ...gams.map(function(i) {
            return genotype[position + 1] + i;
          })
        ];
      }
    };
    return helper(genotype, 0);
  };

  onChangeText = function() {
    var allel, alleles, gametes;
    clearError();
    htmlset("gametparams", "");
    if (!checkGenotypes(valueof("genotype1"), valueof("genotype2"))) {
      return;
    }
    gametes = makeGametes(valueof("genotype1"));
    if (gametes === null) {
      return;
    }
    alleles = mergeStrings(gametes[0].toUpperCase(), gametes[0].toLowerCase());
    return htmlset("gametparams", ((function() {
      var l, len, results;
      results = [];
      for (l = 0, len = alleles.length; l < len; l++) {
        allel = alleles[l];
        results.push(createPhenotypeInput(allel));
      }
      return results;
    })()).join(""));
  };

  createPhenotypeInput = function(allel) {
    return `<div class="form-group">
	<div class="mdl-textfield mdl-js-textfield">
		<label for="inputFor${allel}" class="small">Фенотип ${allel}</label>
		<input type="text" class="form-control" id="inputFor${allel}">
	</div>
</div>`;
  };

  checkGenotype = function(genotype) {
    var msg;
    msg = `Введён некорректный генотип ${genotype}`;
    if (genotype.length % 2 !== 0) { // поддерживаются только аллели кратные двум
      return fail(msg);
    }
    return true;
  };

  checkGenotypes = function(genotype1, genotype2) {
    var i, l, msg, ref;
    if (!checkGenotype(genotype1 || checkGenotype(genotype2))) {
      return false;
    }
    msg = `Генотипы ${genotype1} и ${genotype2} некорректны`;
    if (genotype1.length !== genotype2.length) { // число аллелей должно быть одинаковым
      return fail(msg);
    }
// порядок аллелей должен быть одинаковым
    for (i = l = 0, ref = genotype1.length; (0 <= ref ? l < ref : l > ref); i = 0 <= ref ? ++l : --l) {
      if (genotype1[i].toLowerCase() !== genotype2[i].toLowerCase()) {
        return fail(msg);
      }
    }
    return true;
  };

  mergeStrings = function(string1, string2) {
    var i;
    return ((function() {
      var l, ref, results;
      results = [];
      for (i = l = 0, ref = string1.length; (0 <= ref ? l < ref : l > ref); i = 0 <= ref ? ++l : --l) {
        results.push(string1[i] + string2[i]);
      }
      return results;
    })()).join("");
  };

  element("genotype1").addEventListener("input", onChangeText);

  element("genotype2").addEventListener("input", onChangeText);

  element("runButton").addEventListener("click", runApplication);

}).call(this);
