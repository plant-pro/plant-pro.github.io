// Generated by CoffeeScript 2.5.1
(function() {
  /*
  	Complementarity application (EN version)
  	Autor: Tsvikevich Denis 2019
  */
  var DNA_COMPLIMENTARY, DNA_VALID_CHARS, GENETIC_CODE, INPUT_TYPE, RNA_COMPLIMENTARY, RNA_VALID_CHARS, all, any, buildByDnaOne, buildByDnaTwo, buildByInformationalRna, buildByProtein, buildByTransferRna, checkedof, clearError, countIt, delws, div, ejoin, element, first, formatOutput, formatProteinSequence, getCheckerAndInputElement, h1, h2, h3, h4, h5, h6, htmlget, htmlset, isValidAminoacid, isValidDnaChar, isValidRnaChar, keys, last, lastInputType, logError, makeComplimentaryDna, makeDnaFromiRna, makeInformationalRna, makeInformationalRnaFromProtein, makeKeyCells, makeMapCells, makeProteinFromInformationalRna, makeTransferRna, makeValueCells, mapString, max, maxKey, maxValue, min, mul, neue, neueText, runApplication, runParser, sub, sum, uniformNucleotide, uniformSequence, unique, validateInput, valueof, values, valueset,
    indexOf = [].indexOf;

  // Operator function for '-'
  sub = function(x, y) {
    return x - y;
  };

  // Operator function for '+', also allow to sum of array
  sum = function(x, y) {
    if (y == null) {
      return x.reduce(document.flexibel.sum);
    }
    return x + y;
  };

  // Operator function for '*', also allow to mul of array
  mul = function(x, y) {
    if (y == null) {
      return x.reduce(document.flexibel.mul);
    }
    return x * y;
  };

  // Operator function for '/'
  div = function(x, y) {
    return x / y;
  };

  // Returns the min of two elements, or min of array
  min = function(x, y) {
    if (y == null) {
      return x.reduce(document.flexibel.min);
    }
    if (x < y) {
      return x;
    } else {
      return y;
    }
  };

  // Returns the max of two elements, or max of array
  max = function(x, y) {
    if (y == null) {
      return x.reduce(document.flexibel.max);
    }
    if (x > y) {
      return x;
    } else {
      return y;
    }
  };

  last = function(container) {
    return container[container.length - 1];
  };

  first = function(container) {
    return container[0];
  };

  neue = function(name, inner) {
    var elem;
    elem = document.createElement(name);
    if (inner != null) {
      elem.innerHTML = inner;
    }
    return elem;
  };

  neueText = function(name, inner) {
    var elem;
    elem = document.createElement(name);
    if (inner != null) {
      elem.innerText = inner;
    }
    return elem;
  };

  div = function(inner) {
    var elem;
    elem = document.createElement("div");
    if (inner != null) {
      elem.innerHTML = inner;
    }
    return elem;
  };

  h1 = function(text) {
    return neueText("h1", text);
  };

  h2 = function(text) {
    return neueText("h2", text);
  };

  h3 = function(text) {
    return neueText("h3", text);
  };

  h4 = function(text) {
    return neueText("h4", text);
  };

  h5 = function(text) {
    return neueText("h5", text);
  };

  h6 = function(text) {
    return neueText("h6", text);
  };

  element = function(id) {
    if (id.startsWith(".")) {
      return document.getElementsByClassName(id.substring(1));
    }
    return document.getElementById(id);
  };

  valueset = function(id, value) {
    return document.flexibel.element(id).value = value;
  };

  valueof = function(id) {
    return document.flexibel.element(id).value;
  };

  checkedof = function(id) {
    return document.flexibel.element(id).checked;
  };

  htmlset = function(id, html) {
    return document.flexibel.element(id).innerHTML = html;
  };

  htmlget = function(id) {
    return document.flexibel.element(id).innerHTML;
  };

  any = function(values, f) {
    var i, j, len;
    for (j = 0, len = values.length; j < len; j++) {
      i = values[j];
      if (f(i)) {
        return true;
      }
    }
    return false;
  };

  all = function(values, f) {
    var i, j, len;
    for (j = 0, len = values.length; j < len; j++) {
      i = values[j];
      if (!f(i)) {
        return false;
      }
    }
    return true;
  };

  ejoin = function(values) {
    return values.join("");
  };

  delws = function(str, sym) {
    return str.replace(/\s+/g, "");
  };

  values = function(map) {
    return [...map.values()];
  };

  keys = function(map) {
    return [...map.keys()];
  };

  maxKey = function(map) {
    return document.flexibel.keys(map).reduce(document.flexibel.max);
  };

  maxValue = function(map) {
    return document.flexibel.values(map).reduce(document.flexibel.max);
  };

  unique = function(values) {
    return [...new Set(values)];
  };

  countIt = function(map, it) {
    if (map.has(it)) {
      return map.set(it, map.get(it) + 1);
    } else {
      return map.set(it, 1);
    }
  };

  makeValueCells = function(map) {
    var ref, results, v;
    ref = map.values();
    results = [];
    for (v of ref) {
      results.push(`<td>${v}</td>`);
    }
    return results;
  };

  makeKeyCells = function(map) {
    var k, ref, results;
    ref = map.keys();
    results = [];
    for (k of ref) {
      results.push(`<td>${k}</td>`);
    }
    return results;
  };

  makeMapCells = function(values, mapper) {
    var k, results;
    results = [];
    for (k of values) {
      results.push(`<td>${mapper(k)}</td>`);
    }
    return results;
  };

  document.flexibel = {makeKeyCells, makeValueCells, countIt, maxValue, maxKey, keys, values, delws, ejoin, htmlset, checkedof, valueof, valueset, element, first, last, max, min, sum, sub, mul, div, all, any};

  runParser = function(input) {
    var getCurrent, next, parseNumber, parserState, ref;
    parserState = {
      result: [],
      currentPosition: 0,
      input: input
    };
    getCurrent = function(state) {
      return state.input[state.currentPosition];
    };
    next = function(state) {
      var current;
      current = getCurrent(state);
      state.currentPosition++;
      return current;
    };
    parseNumber = function(state) {
      var buffer, current, ref;
      buffer = next(state);
      while (ref = (current = next(state)), indexOf.call("0123456789.", ref) >= 0) {
        buffer += current;
      }
      return state.result.push(parseFloat(buffer));
    };
    while (parserState.currentPosition < input.length) {
      if (ref = getCurrent(parserState), indexOf.call("0123456789-", ref) >= 0) {
        parseNumber(parserState);
      } else {
        next(parserState);
      }
    }
    return parserState.result;
  };

  DNA_VALID_CHARS = "ATGCatgcATGCATGC ";

  RNA_VALID_CHARS = "AUGCaugcAUGCAUGC ";

  DNA_COMPLIMENTARY = new Map([["A", "T"], ["T", "A"], ["G", "C"], ["U", "A"], ["C", "G"]]);

  RNA_COMPLIMENTARY = new Map([["A", "U"], ["T", "A"], ["U", "A"], ["G", "C"], ["C", "G"]]);

  GENETIC_CODE = new Map([["UUU", "PHE"], ["UUC", "PHE"], ["UUA", "LEU"], ["UCU", "SER"], ["UCC", "SER"], ["UCA", "SER"], ["UCG", "SER"], ["UAU", "TYR"], ["UAC", "TYR"], ["UAA", "STOP"], ["UAG", "STOP"], ["UGU", "CYS"], ["UGC", "CYS"], ["UGA", "STOP"], ["UGG", "TRP"], ["CUU", "LEU"], ["CUC", "LEU"], ["CUA", "LEU"], ["CUG", "LEU"], ["CCU", "PRO"], ["CCC", "PRO"], ["CCA", "PRO"], ["CCG", "PRO"], ["CAU", "HIS"], ["CAC", "HIS"], ["CAA", "GLU"], ["CAG", "GLU"], ["CGU", "ARG"], ["CGC", "ARG"], ["CGA", "ARG"], ["CGG", "ARG"], ["AUU", "ILE"], ["AUC", "ILE"], ["AUA", "ILE"], ["AUG", "MET"], ["GUU", "VAL"], ["GUC", "VAL"], ["GUA", "VAL"], ["GUG", "VAL"], ["ACU", "THR"], ["ACC", "THR"], ["ACA", "THR"], ["ACG", "THR"], ["GCU", "ALA"], ["GCC", "ALA"], ["GCA", "ALA"], ["GCG", "ALA"], ["AAU", "ASN"], ["AAC", "ASN"], ["AAA", "LYS"], ["AAG", "LYS"], ["GAU", "ASP"], ["GAC", "ASP"], ["GAA", "GLU"], ["GAG", "GLU"], ["AGU", "SER"], ["AGC", "SER"], ["AGA", "ARG"], ["AGG", "ARG"], ["GGU", "GLY"], ["GGC", "GLY"], ["GGA", "GLY"], ["GGG", "GLY"]]);

  INPUT_TYPE = {
    DNA1: 1,
    DNA2: 2,
    IRNA: 3,
    TRNA: 4,
    PROTEIN: 5
  };

  lastInputType = 1;

  runApplication = function() {
    var result;
    result = (function() {
      switch (lastInputType) {
        case 1:
          return buildByDnaOne();
        case 2:
          return buildByDnaTwo();
        case 3:
          return buildByInformationalRna();
        case 4:
          return buildByTransferRna();
        case 5:
          return buildByProtein();
      }
    })();
    valueset("dnaInput", formatOutput(result.firstDna));
    valueset("dna2Input", formatOutput(result.secondDna));
    valueset("irnaInput", formatOutput(result.informationalRna));
    valueset("trnaInput", formatOutput(result.transferRna));
    return valueset("proteinInput", result.protein);
  };

  buildByDnaOne = function() {
    var firstDna, informationalRna, protein, secondDna, transferRna;
    firstDna = uniformSequence(valueof("dnaInput"));
    secondDna = makeComplimentaryDna(firstDna);
    informationalRna = makeInformationalRna(firstDna);
    transferRna = makeTransferRna(informationalRna);
    protein = makeProteinFromInformationalRna(informationalRna);
    return {firstDna, secondDna, informationalRna, transferRna, protein};
  };

  buildByDnaTwo = function() {
    var firstDna, informationalRna, protein, secondDna, transferRna;
    secondDna = uniformSequence(valueof("dna2Input"));
    firstDna = makeComplimentaryDna(secondDna);
    informationalRna = makeInformationalRna(firstDna);
    transferRna = makeTransferRna(informationalRna);
    protein = makeProteinFromInformationalRna(informationalRna);
    return {firstDna, secondDna, informationalRna, transferRna, protein};
  };

  buildByInformationalRna = function() {
    var firstDna, informationalRna, protein, secondDna, transferRna;
    informationalRna = uniformSequence(valueof("irnaInput"));
    firstDna = makeDnaFromiRna(informationalRna);
    secondDna = makeComplimentaryDna(firstDna);
    transferRna = makeTransferRna(informationalRna);
    protein = makeProteinFromInformationalRna(informationalRna);
    return {firstDna, secondDna, informationalRna, transferRna, protein};
  };

  buildByTransferRna = function() {
    var firstDna, informationalRna, protein, secondDna, transferRna;
    transferRna = uniformSequence(valueof("trnaInput"));
    secondDna = makeDnaFromiRna(transferRna);
    firstDna = makeComplimentaryDna(secondDna);
    informationalRna = makeInformationalRna(firstDna);
    protein = makeProteinFromInformationalRna(informationalRna);
    return {firstDna, secondDna, informationalRna, transferRna, protein};
  };

  buildByProtein = function() {
    var firstDna, informationalRna, protein, secondDna, transferRna;
    protein = valueof("proteinInput");
    informationalRna = makeInformationalRnaFromProtein(protein);
    firstDna = makeDnaFromiRna(informationalRna);
    secondDna = makeComplimentaryDna(firstDna);
    transferRna = makeTransferRna(informationalRna);
    return {firstDna, secondDna, informationalRna, transferRna, protein};
  };

  makeProteinFromInformationalRna = function(irna) {
    var divideIntoTriplets;
    divideIntoTriplets = function(irna) {
      var currentTriplet, i, index, j, len, triplets;
      triplets = [];
      currentTriplet = "";
      index = 0;
      for (j = 0, len = irna.length; j < len; j++) {
        i = irna[j];
        currentTriplet += i;
        index++;
        if (index === 3) {
          triplets.push(currentTriplet);
          currentTriplet = "";
          index = 0;
        }
      }
      return triplets;
    };
    return divideIntoTriplets(irna).map(function(x) {
      return GENETIC_CODE.get(x);
    }).join("-");
  };

  makeInformationalRnaFromProtein = function(protein) {
    var aminoacid, i, j, len, ref, result;
    result = "";
    ref = protein.split("-");
    for (j = 0, len = ref.length; j < len; j++) {
      aminoacid = ref[j];
      for (i of GENETIC_CODE) {
        if (i[1] === aminoacid) {
          result += i[0];
          break;
        }
      }
    }
    return result;
  };

  mapString = function(string, mapper) {
    var char;
    return ((function() {
      var j, len, results;
      results = [];
      for (j = 0, len = string.length; j < len; j++) {
        char = string[j];
        results.push(mapper(char));
      }
      return results;
    })()).join("");
  };

  makeComplimentaryDna = function(dna) {
    return mapString(dna, function(x) {
      return DNA_COMPLIMENTARY.get(x);
    });
  };

  makeInformationalRna = function(dna1) {
    return mapString(dna1, function(x) {
      return RNA_COMPLIMENTARY.get(x);
    });
  };

  makeDnaFromiRna = function(irna) {
    return mapString(irna, function(x) {
      return DNA_COMPLIMENTARY.get(x);
    });
  };

  makeTransferRna = function(irna) {
    return mapString(irna, function(x) {
      return RNA_COMPLIMENTARY.get(x);
    });
  };

  uniformSequence = function(dna) {
    return mapString(delws(dna), uniformNucleotide);
  };

  uniformNucleotide = function(nucleotide) {
    switch (nucleotide.toUpperCase()) {
      case "A":
        return "A";
      case "Т":
        return "T";
      case "Г":
        return "G";
      case "Ц":
        return "C";
      case "У":
        return "U";
      default:
        return nucleotide.toUpperCase();
    }
  };

  validateInput = function(type) {
    var aminoacid, checker, formatedInput, i, inputElement, j, l, len, len1, ref, ref1;
    lastInputType = type;
    clearError();
    if (type === INPUT_TYPE.PROTEIN) {
      formatedInput = formatProteinSequence(valueof("proteinInput").replace(/\-/g, ''));
      ref = formatedInput.split("-");
      for (j = 0, len = ref.length; j < len; j++) {
        aminoacid = ref[j];
        if (!isValidAminoacid(aminoacid)) {
          return logError(`Error: unknown aminoacid '${aminoacid}'`, type);
        }
      }
      return document.mainForm.proteinInput.value = formatedInput;
    } else {
      ({checker, inputElement} = getCheckerAndInputElement(type));
      ref1 = inputElement.value;
      for (l = 0, len1 = ref1.length; l < len1; l++) {
        i = ref1[l];
        if (!checker(i)) {
          return logError(`Error: unexpected symbol '${i}'`, type);
        }
      }
      inputElement.value = formatOutput(delws(inputElement.value));
      if (uniformSequence(inputElement.value).length % 3 !== 0) {
        return logError("Error: partial triplet", type);
      }
    }
  };

  getCheckerAndInputElement = function(inputType) {
    switch (inputType) {
      case 1:
        return {
          checker: isValidDnaChar,
          inputElement: element("dnaInput")
        };
      case 2:
        return {
          checker: isValidDnaChar,
          inputElement: element("dna2Input")
        };
      case 3:
        return {
          checker: isValidRnaChar,
          inputElement: element("irnaInput")
        };
      case 4:
        return {
          checker: isValidRnaChar,
          inputElement: element("trnaInput")
        };
      default:
        return {
          checker: isValidDnaChar,
          inputElement: element("dnaInput")
        };
    }
  };

  isValidAminoacid = function(aminoacid) {
    var isPart, normalizedAminoacid, ref, v;
    if (aminoacid.length === 0) {
      return true;
    }
    normalizedAminoacid = aminoacid.toUpperCase();
    ref = GENETIC_CODE.values();
    for (v of ref) {
      isPart = v.startsWith(normalizedAminoacid);
      if (isPart) {
        break;
      }
    }
    return isPart;
  };

  isValidDnaChar = function(char) {
    return indexOf.call(DNA_VALID_CHARS, char) >= 0;
  };

  isValidRnaChar = function(char) {
    return indexOf.call(RNA_VALID_CHARS, char) >= 0;
  };

  logError = function(message, inputType) {
    var logger;
    logger = (function() {
      switch (inputType) {
        case INPUT_TYPE.DNA1:
          return element("dna1err");
        case INPUT_TYPE.DNA2:
          return element("dna2err");
        case INPUT_TYPE.IRNA:
          return element("irnaerr");
        case INPUT_TYPE.TRNA:
          return element("trnaerr");
        case INPUT_TYPE.PROTEIN:
          return element("proteinerr");
      }
    })();
    return logger.innerHTML = message;
  };

  clearError = function() {
    var i, j, results;
    results = [];
    for (i = j = 1; j <= 5; i = ++j) {
      results.push(logError("", i));
    }
    return results;
  };

  formatOutput = function(sequence) {
    var currentTriplet, i, index, j, len, ref, triplets;
    triplets = [];
    currentTriplet = "";
    index = 0;
    ref = uniformSequence(sequence);
    for (j = 0, len = ref.length; j < len; j++) {
      i = ref[j];
      currentTriplet += i;
      index++;
      if (index === 3) {
        triplets.push(currentTriplet);
        currentTriplet = "";
        index = 0;
      }
    }
    if (currentTriplet.length > 0) {
      triplets.push(currentTriplet);
    }
    return triplets.join(" ");
  };

  formatProteinSequence = function(sequence) {
    var currentTriplet, i, index, j, len, ref, triplets;
    triplets = [];
    currentTriplet = "";
    index = 0;
    ref = sequence.toUpperCase();
    for (j = 0, len = ref.length; j < len; j++) {
      i = ref[j];
      currentTriplet += i;
      index++;
      if ((index === 3 && currentTriplet !== "Sto") || (index === 4)) {
        triplets.push(currentTriplet);
        currentTriplet = "";
        index = 0;
      }
    }
    if (currentTriplet.length > 0) {
      triplets.push(currentTriplet);
    }
    return triplets.join("-");
  };

  element("dnaInput").addEventListener("input", function() {
    return validateInput(INPUT_TYPE.DNA1);
  });

  element("dna2Input").addEventListener("input", function() {
    return validateInput(INPUT_TYPE.DNA2);
  });

  element("irnaInput").addEventListener("input", function() {
    return validateInput(INPUT_TYPE.IRNA);
  });

  element("trnaInput").addEventListener("input", function() {
    return validateInput(INPUT_TYPE.TRNA);
  });

  element("proteinInput").addEventListener("input", function() {
    return validateInput(INPUT_TYPE.PROTEIN);
  });

  element("runButton").addEventListener("click", runApplication);

}).call(this);
