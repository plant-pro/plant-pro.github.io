"use strict";

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// Generated by CoffeeScript 2.5.1
(function () {
  /*
  	Complementarity application (EN version)
  	Autor: Tsvikevich Denis 2019
  */
  var DNA_COMPLIMENTARY,
      DNA_VALID_CHARS,
      GENETIC_CODE,
      INPUT_TYPE,
      RNA_COMPLIMENTARY,
      RNA_VALID_CHARS,
      all,
      any,
      buildByDnaOne,
      buildByDnaTwo,
      buildByInformationalRna,
      buildByProtein,
      buildByTransferRna,
      checkedof,
      clearError,
      countIt,
      delws,
      div,
      ejoin,
      element,
      first,
      formatOutput,
      formatProteinSequence,
      getCheckerAndInputElement,
      h1,
      h2,
      h3,
      h4,
      h5,
      h6,
      htmlget,
      htmlset,
      isValidAminoacid,
      isValidDnaChar,
      isValidRnaChar,
      keys,
      last,
      lastInputType,
      logError,
      makeComplimentaryDna,
      makeDnaFromiRna,
      makeInformationalRna,
      makeInformationalRnaFromProtein,
      makeKeyCells,
      makeMapCells,
      makeProteinFromInformationalRna,
      makeTransferRna,
      makeValueCells,
      mapString,
      max,
      maxKey,
      maxValue,
      min,
      mul,
      neue,
      neueText,
      runApplication,
      runParser,
      sub,
      sum,
      uniformNucleotide,
      uniformSequence,
      unique,
      validateInput,
      valueof,
      values,
      valueset,
      indexOf = [].indexOf; // Operator function for '-'

  sub = function sub(x, y) {
    return x - y;
  }; // Operator function for '+', also allow to sum of array


  sum = function sum(x, y) {
    if (y == null) {
      return x.reduce(document.flexibel.sum);
    }

    return x + y;
  }; // Operator function for '*', also allow to mul of array


  mul = function mul(x, y) {
    if (y == null) {
      return x.reduce(document.flexibel.mul);
    }

    return x * y;
  }; // Operator function for '/'


  div = function div(x, y) {
    return x / y;
  }; // Returns the min of two elements, or min of array


  min = function min(x, y) {
    if (y == null) {
      return x.reduce(document.flexibel.min);
    }

    if (x < y) {
      return x;
    } else {
      return y;
    }
  }; // Returns the max of two elements, or max of array


  max = function max(x, y) {
    if (y == null) {
      return x.reduce(document.flexibel.max);
    }

    if (x > y) {
      return x;
    } else {
      return y;
    }
  };

  last = function last(container) {
    return container[container.length - 1];
  };

  first = function first(container) {
    return container[0];
  };

  neue = function neue(name, inner) {
    var elem;
    elem = document.createElement(name);

    if (inner != null) {
      elem.innerHTML = inner;
    }

    return elem;
  };

  neueText = function neueText(name, inner) {
    var elem;
    elem = document.createElement(name);

    if (inner != null) {
      elem.innerText = inner;
    }

    return elem;
  };

  div = function div(inner) {
    var elem;
    elem = document.createElement("div");

    if (inner != null) {
      elem.innerHTML = inner;
    }

    return elem;
  };

  h1 = function h1(text) {
    return neueText("h1", text);
  };

  h2 = function h2(text) {
    return neueText("h2", text);
  };

  h3 = function h3(text) {
    return neueText("h3", text);
  };

  h4 = function h4(text) {
    return neueText("h4", text);
  };

  h5 = function h5(text) {
    return neueText("h5", text);
  };

  h6 = function h6(text) {
    return neueText("h6", text);
  };

  element = function element(id) {
    if (id.startsWith(".")) {
      return document.getElementsByClassName(id.substring(1));
    }

    return document.getElementById(id);
  };

  valueset = function valueset(id, value) {
    return document.flexibel.element(id).value = value;
  };

  valueof = function valueof(id) {
    return document.flexibel.element(id).value;
  };

  checkedof = function checkedof(id) {
    return document.flexibel.element(id).checked;
  };

  htmlset = function htmlset(id, html) {
    return document.flexibel.element(id).innerHTML = html;
  };

  htmlget = function htmlget(id) {
    return document.flexibel.element(id).innerHTML;
  };

  any = function any(values, f) {
    var i, j, len;

    for (j = 0, len = values.length; j < len; j++) {
      i = values[j];

      if (f(i)) {
        return true;
      }
    }

    return false;
  };

  all = function all(values, f) {
    var i, j, len;

    for (j = 0, len = values.length; j < len; j++) {
      i = values[j];

      if (!f(i)) {
        return false;
      }
    }

    return true;
  };

  ejoin = function ejoin(values) {
    return values.join("");
  };

  delws = function delws(str, sym) {
    return str.replace(/\s+/g, "");
  };

  values = function values(map) {
    return _toConsumableArray(map.values());
  };

  keys = function keys(map) {
    return _toConsumableArray(map.keys());
  };

  maxKey = function maxKey(map) {
    return document.flexibel.keys(map).reduce(document.flexibel.max);
  };

  maxValue = function maxValue(map) {
    return document.flexibel.values(map).reduce(document.flexibel.max);
  };

  unique = function unique(values) {
    return _toConsumableArray(new Set(values));
  };

  countIt = function countIt(map, it) {
    if (map.has(it)) {
      return map.set(it, map.get(it) + 1);
    } else {
      return map.set(it, 1);
    }
  };

  makeValueCells = function makeValueCells(map) {
    var ref, results, v;
    ref = map.values();
    results = [];

    var _iterator = _createForOfIteratorHelper(ref),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        v = _step.value;
        results.push("<td>".concat(v, "</td>"));
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return results;
  };

  makeKeyCells = function makeKeyCells(map) {
    var k, ref, results;
    ref = map.keys();
    results = [];

    var _iterator2 = _createForOfIteratorHelper(ref),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        k = _step2.value;
        results.push("<td>".concat(k, "</td>"));
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }

    return results;
  };

  makeMapCells = function makeMapCells(values, mapper) {
    var k, results;
    results = [];

    var _iterator3 = _createForOfIteratorHelper(values),
        _step3;

    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
        k = _step3.value;
        results.push("<td>".concat(mapper(k), "</td>"));
      }
    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }

    return results;
  };

  document.flexibel = {
    makeKeyCells: makeKeyCells,
    makeValueCells: makeValueCells,
    countIt: countIt,
    maxValue: maxValue,
    maxKey: maxKey,
    keys: keys,
    values: values,
    delws: delws,
    ejoin: ejoin,
    htmlset: htmlset,
    checkedof: checkedof,
    valueof: valueof,
    valueset: valueset,
    element: element,
    first: first,
    last: last,
    max: max,
    min: min,
    sum: sum,
    sub: sub,
    mul: mul,
    div: div,
    all: all,
    any: any
  };

  runParser = function runParser(input) {
    var getCurrent, next, parseNumber, parserState, ref;
    parserState = {
      result: [],
      currentPosition: 0,
      input: input
    };

    getCurrent = function getCurrent(state) {
      return state.input[state.currentPosition];
    };

    next = function next(state) {
      var current;
      current = getCurrent(state);
      state.currentPosition++;
      return current;
    };

    parseNumber = function parseNumber(state) {
      var buffer, current, ref;
      buffer = next(state);

      while (ref = current = next(state), indexOf.call("0123456789.", ref) >= 0) {
        buffer += current;
      }

      return state.result.push(parseFloat(buffer));
    };

    while (parserState.currentPosition < input.length) {
      if (ref = getCurrent(parserState), indexOf.call("0123456789-", ref) >= 0) {
        parseNumber(parserState);
      } else {
        next(parserState);
      }
    }

    return parserState.result;
  };

  DNA_VALID_CHARS = "ATGCatgcATGCATGC ";
  RNA_VALID_CHARS = "AUGCaugcAUGCAUGC ";
  DNA_COMPLIMENTARY = new Map([["A", "T"], ["T", "A"], ["G", "C"], ["U", "A"], ["C", "G"]]);
  RNA_COMPLIMENTARY = new Map([["A", "U"], ["T", "A"], ["U", "A"], ["G", "C"], ["C", "G"]]);
  GENETIC_CODE = new Map([["UUU", "PHE"], ["UUC", "PHE"], ["UUA", "LEU"], ["UCU", "SER"], ["UCC", "SER"], ["UCA", "SER"], ["UCG", "SER"], ["UAU", "TYR"], ["UAC", "TYR"], ["UAA", "STOP"], ["UAG", "STOP"], ["UGU", "CYS"], ["UGC", "CYS"], ["UGA", "STOP"], ["UGG", "TRP"], ["CUU", "LEU"], ["CUC", "LEU"], ["CUA", "LEU"], ["CUG", "LEU"], ["CCU", "PRO"], ["CCC", "PRO"], ["CCA", "PRO"], ["CCG", "PRO"], ["CAU", "HIS"], ["CAC", "HIS"], ["CAA", "GLU"], ["CAG", "GLU"], ["CGU", "ARG"], ["CGC", "ARG"], ["CGA", "ARG"], ["CGG", "ARG"], ["AUU", "ILE"], ["AUC", "ILE"], ["AUA", "ILE"], ["AUG", "MET"], ["GUU", "VAL"], ["GUC", "VAL"], ["GUA", "VAL"], ["GUG", "VAL"], ["ACU", "THR"], ["ACC", "THR"], ["ACA", "THR"], ["ACG", "THR"], ["GCU", "ALA"], ["GCC", "ALA"], ["GCA", "ALA"], ["GCG", "ALA"], ["AAU", "ASN"], ["AAC", "ASN"], ["AAA", "LYS"], ["AAG", "LYS"], ["GAU", "ASP"], ["GAC", "ASP"], ["GAA", "GLU"], ["GAG", "GLU"], ["AGU", "SER"], ["AGC", "SER"], ["AGA", "ARG"], ["AGG", "ARG"], ["GGU", "GLY"], ["GGC", "GLY"], ["GGA", "GLY"], ["GGG", "GLY"]]);
  INPUT_TYPE = {
    DNA1: 1,
    DNA2: 2,
    IRNA: 3,
    TRNA: 4,
    PROTEIN: 5
  };
  lastInputType = 1;

  runApplication = function runApplication() {
    var result;

    result = function () {
      switch (lastInputType) {
        case 1:
          return buildByDnaOne();

        case 2:
          return buildByDnaTwo();

        case 3:
          return buildByInformationalRna();

        case 4:
          return buildByTransferRna();

        case 5:
          return buildByProtein();
      }
    }();

    valueset("dnaInput", formatOutput(result.firstDna));
    valueset("dna2Input", formatOutput(result.secondDna));
    valueset("irnaInput", formatOutput(result.informationalRna));
    valueset("trnaInput", formatOutput(result.transferRna));
    return valueset("proteinInput", result.protein);
  };

  buildByDnaOne = function buildByDnaOne() {
    var firstDna, informationalRna, protein, secondDna, transferRna;
    firstDna = uniformSequence(valueof("dnaInput"));
    secondDna = makeComplimentaryDna(firstDna);
    informationalRna = makeInformationalRna(firstDna);
    transferRna = makeTransferRna(informationalRna);
    protein = makeProteinFromInformationalRna(informationalRna);
    return {
      firstDna: firstDna,
      secondDna: secondDna,
      informationalRna: informationalRna,
      transferRna: transferRna,
      protein: protein
    };
  };

  buildByDnaTwo = function buildByDnaTwo() {
    var firstDna, informationalRna, protein, secondDna, transferRna;
    secondDna = uniformSequence(valueof("dna2Input"));
    firstDna = makeComplimentaryDna(secondDna);
    informationalRna = makeInformationalRna(firstDna);
    transferRna = makeTransferRna(informationalRna);
    protein = makeProteinFromInformationalRna(informationalRna);
    return {
      firstDna: firstDna,
      secondDna: secondDna,
      informationalRna: informationalRna,
      transferRna: transferRna,
      protein: protein
    };
  };

  buildByInformationalRna = function buildByInformationalRna() {
    var firstDna, informationalRna, protein, secondDna, transferRna;
    informationalRna = uniformSequence(valueof("irnaInput"));
    firstDna = makeDnaFromiRna(informationalRna);
    secondDna = makeComplimentaryDna(firstDna);
    transferRna = makeTransferRna(informationalRna);
    protein = makeProteinFromInformationalRna(informationalRna);
    return {
      firstDna: firstDna,
      secondDna: secondDna,
      informationalRna: informationalRna,
      transferRna: transferRna,
      protein: protein
    };
  };

  buildByTransferRna = function buildByTransferRna() {
    var firstDna, informationalRna, protein, secondDna, transferRna;
    transferRna = uniformSequence(valueof("trnaInput"));
    secondDna = makeDnaFromiRna(transferRna);
    firstDna = makeComplimentaryDna(secondDna);
    informationalRna = makeInformationalRna(firstDna);
    protein = makeProteinFromInformationalRna(informationalRna);
    return {
      firstDna: firstDna,
      secondDna: secondDna,
      informationalRna: informationalRna,
      transferRna: transferRna,
      protein: protein
    };
  };

  buildByProtein = function buildByProtein() {
    var firstDna, informationalRna, protein, secondDna, transferRna;
    protein = valueof("proteinInput");
    informationalRna = makeInformationalRnaFromProtein(protein);
    firstDna = makeDnaFromiRna(informationalRna);
    secondDna = makeComplimentaryDna(firstDna);
    transferRna = makeTransferRna(informationalRna);
    return {
      firstDna: firstDna,
      secondDna: secondDna,
      informationalRna: informationalRna,
      transferRna: transferRna,
      protein: protein
    };
  };

  makeProteinFromInformationalRna = function makeProteinFromInformationalRna(irna) {
    var divideIntoTriplets;

    divideIntoTriplets = function divideIntoTriplets(irna) {
      var currentTriplet, i, index, j, len, triplets;
      triplets = [];
      currentTriplet = "";
      index = 0;

      for (j = 0, len = irna.length; j < len; j++) {
        i = irna[j];
        currentTriplet += i;
        index++;

        if (index === 3) {
          triplets.push(currentTriplet);
          currentTriplet = "";
          index = 0;
        }
      }

      return triplets;
    };

    return divideIntoTriplets(irna).map(function (x) {
      return GENETIC_CODE.get(x);
    }).join("-");
  };

  makeInformationalRnaFromProtein = function makeInformationalRnaFromProtein(protein) {
    var aminoacid, i, j, len, ref, result;
    result = "";
    ref = protein.split("-");

    for (j = 0, len = ref.length; j < len; j++) {
      aminoacid = ref[j];

      var _iterator4 = _createForOfIteratorHelper(GENETIC_CODE),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          i = _step4.value;

          if (i[1] === aminoacid) {
            result += i[0];
            break;
          }
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
    }

    return result;
  };

  mapString = function mapString(string, mapper) {
    var _char;

    return function () {
      var j, len, results;
      results = [];

      for (j = 0, len = string.length; j < len; j++) {
        _char = string[j];
        results.push(mapper(_char));
      }

      return results;
    }().join("");
  };

  makeComplimentaryDna = function makeComplimentaryDna(dna) {
    return mapString(dna, function (x) {
      return DNA_COMPLIMENTARY.get(x);
    });
  };

  makeInformationalRna = function makeInformationalRna(dna1) {
    return mapString(dna1, function (x) {
      return RNA_COMPLIMENTARY.get(x);
    });
  };

  makeDnaFromiRna = function makeDnaFromiRna(irna) {
    return mapString(irna, function (x) {
      return DNA_COMPLIMENTARY.get(x);
    });
  };

  makeTransferRna = function makeTransferRna(irna) {
    return mapString(irna, function (x) {
      return RNA_COMPLIMENTARY.get(x);
    });
  };

  uniformSequence = function uniformSequence(dna) {
    return mapString(delws(dna), uniformNucleotide);
  };

  uniformNucleotide = function uniformNucleotide(nucleotide) {
    switch (nucleotide.toUpperCase()) {
      case "A":
        return "A";

      case "Т":
        return "T";

      case "Г":
        return "G";

      case "Ц":
        return "C";

      case "У":
        return "U";

      default:
        return nucleotide.toUpperCase();
    }
  };

  validateInput = function validateInput(type) {
    var aminoacid, checker, formatedInput, i, inputElement, j, l, len, len1, ref, ref1;
    lastInputType = type;
    clearError();

    if (type === INPUT_TYPE.PROTEIN) {
      formatedInput = formatProteinSequence(valueof("proteinInput").replace(/\-/g, ''));
      ref = formatedInput.split("-");

      for (j = 0, len = ref.length; j < len; j++) {
        aminoacid = ref[j];

        if (!isValidAminoacid(aminoacid)) {
          return logError("Error: unknown aminoacid '".concat(aminoacid, "'"), type);
        }
      }

      return document.mainForm.proteinInput.value = formatedInput;
    } else {
      var _getCheckerAndInputEl = getCheckerAndInputElement(type);

      checker = _getCheckerAndInputEl.checker;
      inputElement = _getCheckerAndInputEl.inputElement;
      ref1 = inputElement.value;

      for (l = 0, len1 = ref1.length; l < len1; l++) {
        i = ref1[l];

        if (!checker(i)) {
          return logError("Error: unexpected symbol '".concat(i, "'"), type);
        }
      }

      inputElement.value = formatOutput(delws(inputElement.value));

      if (uniformSequence(inputElement.value).length % 3 !== 0) {
        return logError("Error: partial triplet", type);
      }
    }
  };

  getCheckerAndInputElement = function getCheckerAndInputElement(inputType) {
    switch (inputType) {
      case 1:
        return {
          checker: isValidDnaChar,
          inputElement: element("dnaInput")
        };

      case 2:
        return {
          checker: isValidDnaChar,
          inputElement: element("dna2Input")
        };

      case 3:
        return {
          checker: isValidRnaChar,
          inputElement: element("irnaInput")
        };

      case 4:
        return {
          checker: isValidRnaChar,
          inputElement: element("trnaInput")
        };

      default:
        return {
          checker: isValidDnaChar,
          inputElement: element("dnaInput")
        };
    }
  };

  isValidAminoacid = function isValidAminoacid(aminoacid) {
    var isPart, normalizedAminoacid, ref, v;

    if (aminoacid.length === 0) {
      return true;
    }

    normalizedAminoacid = aminoacid.toUpperCase();
    ref = GENETIC_CODE.values();

    var _iterator5 = _createForOfIteratorHelper(ref),
        _step5;

    try {
      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
        v = _step5.value;
        isPart = v.startsWith(normalizedAminoacid);

        if (isPart) {
          break;
        }
      }
    } catch (err) {
      _iterator5.e(err);
    } finally {
      _iterator5.f();
    }

    return isPart;
  };

  isValidDnaChar = function isValidDnaChar(_char2) {
    return indexOf.call(DNA_VALID_CHARS, _char2) >= 0;
  };

  isValidRnaChar = function isValidRnaChar(_char3) {
    return indexOf.call(RNA_VALID_CHARS, _char3) >= 0;
  };

  logError = function logError(message, inputType) {
    var logger;

    logger = function () {
      switch (inputType) {
        case INPUT_TYPE.DNA1:
          return element("dna1err");

        case INPUT_TYPE.DNA2:
          return element("dna2err");

        case INPUT_TYPE.IRNA:
          return element("irnaerr");

        case INPUT_TYPE.TRNA:
          return element("trnaerr");

        case INPUT_TYPE.PROTEIN:
          return element("proteinerr");
      }
    }();

    return logger.innerHTML = message;
  };

  clearError = function clearError() {
    var i, j, results;
    results = [];

    for (i = j = 1; j <= 5; i = ++j) {
      results.push(logError("", i));
    }

    return results;
  };

  formatOutput = function formatOutput(sequence) {
    var currentTriplet, i, index, j, len, ref, triplets;
    triplets = [];
    currentTriplet = "";
    index = 0;
    ref = uniformSequence(sequence);

    for (j = 0, len = ref.length; j < len; j++) {
      i = ref[j];
      currentTriplet += i;
      index++;

      if (index === 3) {
        triplets.push(currentTriplet);
        currentTriplet = "";
        index = 0;
      }
    }

    if (currentTriplet.length > 0) {
      triplets.push(currentTriplet);
    }

    return triplets.join(" ");
  };

  formatProteinSequence = function formatProteinSequence(sequence) {
    var currentTriplet, i, index, j, len, ref, triplets;
    triplets = [];
    currentTriplet = "";
    index = 0;
    ref = sequence.toUpperCase();

    for (j = 0, len = ref.length; j < len; j++) {
      i = ref[j];
      currentTriplet += i;
      index++;

      if (index === 3 && currentTriplet !== "Sto" || index === 4) {
        triplets.push(currentTriplet);
        currentTriplet = "";
        index = 0;
      }
    }

    if (currentTriplet.length > 0) {
      triplets.push(currentTriplet);
    }

    return triplets.join("-");
  };

  element("dnaInput").addEventListener("input", function () {
    return validateInput(INPUT_TYPE.DNA1);
  });
  element("dna2Input").addEventListener("input", function () {
    return validateInput(INPUT_TYPE.DNA2);
  });
  element("irnaInput").addEventListener("input", function () {
    return validateInput(INPUT_TYPE.IRNA);
  });
  element("trnaInput").addEventListener("input", function () {
    return validateInput(INPUT_TYPE.TRNA);
  });
  element("proteinInput").addEventListener("input", function () {
    return validateInput(INPUT_TYPE.PROTEIN);
  });
  element("runButton").addEventListener("click", runApplication);
}).call(void 0);