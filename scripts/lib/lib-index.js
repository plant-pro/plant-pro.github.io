// Generated by CoffeeScript 2.5.1
(function() {
  // Operator function for '-'
  var all, any, applyPredicates, articlePredicate, checkedof, clearFilter, countIt, delws, div, ejoin, element, first, h1, h2, h3, h4, h5, h6, htmlget, htmlset, indexOfArticlePredicate, isAll, keys, last, makeChip, makeChipWithColor, makeKeyCells, makeMapCells, makeValueCells, max, maxKey, maxValue, min, mul, neue, neueText, predicates, runParser, sub, sum, unique, valueof, values, valueset,
    indexOf = [].indexOf;

  sub = function(x, y) {
    return x - y;
  };

  // Operator function for '+', also allow to sum of array
  sum = function(x, y) {
    if (y == null) {
      return x.reduce(document.flexibel.sum);
    }
    return x + y;
  };

  // Operator function for '*', also allow to mul of array
  mul = function(x, y) {
    if (y == null) {
      return x.reduce(document.flexibel.mul);
    }
    return x * y;
  };

  // Operator function for '/'
  div = function(x, y) {
    return x / y;
  };

  // Returns the min of two elements, or min of array
  min = function(x, y) {
    if (y == null) {
      return x.reduce(document.flexibel.min);
    }
    if (x < y) {
      return x;
    } else {
      return y;
    }
  };

  // Returns the max of two elements, or max of array
  max = function(x, y) {
    if (y == null) {
      return x.reduce(document.flexibel.max);
    }
    if (x > y) {
      return x;
    } else {
      return y;
    }
  };

  last = function(container) {
    return container[container.length - 1];
  };

  first = function(container) {
    return container[0];
  };

  neue = function(name, inner) {
    var elem;
    elem = document.createElement(name);
    if (inner != null) {
      elem.innerHTML = inner;
    }
    return elem;
  };

  neueText = function(name, inner) {
    var elem;
    elem = document.createElement(name);
    if (inner != null) {
      elem.innerText = inner;
    }
    return elem;
  };

  div = function(inner) {
    var elem;
    elem = document.createElement("div");
    if (inner != null) {
      elem.innerHTML = inner;
    }
    return elem;
  };

  h1 = function(text) {
    return neueText("h1", text);
  };

  h2 = function(text) {
    return neueText("h2", text);
  };

  h3 = function(text) {
    return neueText("h3", text);
  };

  h4 = function(text) {
    return neueText("h4", text);
  };

  h5 = function(text) {
    return neueText("h5", text);
  };

  h6 = function(text) {
    return neueText("h6", text);
  };

  element = function(id) {
    if (id.startsWith(".")) {
      return document.getElementsByClassName(id.substring(1));
    }
    return document.getElementById(id);
  };

  valueset = function(id, value) {
    return document.flexibel.element(id).value = value;
  };

  valueof = function(id) {
    return document.flexibel.element(id).value;
  };

  checkedof = function(id) {
    return document.flexibel.element(id).checked;
  };

  htmlset = function(id, html) {
    return document.flexibel.element(id).innerHTML = html;
  };

  htmlget = function(id) {
    return document.flexibel.element(id).innerHTML;
  };

  any = function(values, f) {
    var i, l, len;
    for (l = 0, len = values.length; l < len; l++) {
      i = values[l];
      if (f(i)) {
        return true;
      }
    }
    return false;
  };

  all = function(values, f) {
    var i, l, len;
    for (l = 0, len = values.length; l < len; l++) {
      i = values[l];
      if (!f(i)) {
        return false;
      }
    }
    return true;
  };

  ejoin = function(values) {
    return values.join("");
  };

  delws = function(str, sym) {
    return str.replace(/\s+/g, "");
  };

  values = function(map) {
    return [...map.values()];
  };

  keys = function(map) {
    return [...map.keys()];
  };

  maxKey = function(map) {
    return document.flexibel.keys(map).reduce(document.flexibel.max);
  };

  maxValue = function(map) {
    return document.flexibel.values(map).reduce(document.flexibel.max);
  };

  unique = function(values) {
    return [...new Set(values)];
  };

  countIt = function(map, it) {
    if (map.has(it)) {
      return map.set(it, map.get(it) + 1);
    } else {
      return map.set(it, 1);
    }
  };

  makeValueCells = function(map) {
    var ref, results, v;
    ref = map.values();
    results = [];
    for (v of ref) {
      results.push(`<td>${v}</td>`);
    }
    return results;
  };

  makeKeyCells = function(map) {
    var k, ref, results;
    ref = map.keys();
    results = [];
    for (k of ref) {
      results.push(`<td>${k}</td>`);
    }
    return results;
  };

  makeMapCells = function(values, mapper) {
    var k, results;
    results = [];
    for (k of values) {
      results.push(`<td>${mapper(k)}</td>`);
    }
    return results;
  };

  document.flexibel = {makeKeyCells, makeValueCells, countIt, maxValue, maxKey, keys, values, delws, ejoin, htmlset, checkedof, valueof, valueset, element, first, last, max, min, sum, sub, mul, div, all, any};

  runParser = function(input) {
    var getCurrent, next, parseNumber, parserState, ref;
    parserState = {
      result: [],
      currentPosition: 0,
      input: input
    };
    getCurrent = function(state) {
      return state.input[state.currentPosition];
    };
    next = function(state) {
      var current;
      current = getCurrent(state);
      state.currentPosition++;
      return current;
    };
    parseNumber = function(state) {
      var buffer, current, ref;
      buffer = next(state);
      while (ref = (current = next(state)), indexOf.call("0123456789.", ref) >= 0) {
        buffer += current;
      }
      return state.result.push(parseFloat(buffer));
    };
    while (parserState.currentPosition < input.length) {
      if (ref = getCurrent(parserState), indexOf.call("0123456789-", ref) >= 0) {
        parseNumber(parserState);
      } else {
        next(parserState);
      }
    }
    return parserState.result;
  };

  predicates = [];

  isAll = function(record) {
    var l, len, nullCount, predicate;
    nullCount = 0;
    for (l = 0, len = predicates.length; l < len; l++) {
      predicate = predicates[l];
      if (predicate !== null) {
        if (!predicate(record)) {
          return false;
        }
      } else {
        nullCount += 1;
      }
    }
    if (nullCount === predicates.length) {
      while (predicates.length > 0) {
        predicates.pop();
      }
    }
    return true;
  };

  makeChip = function(text, num) {
    return `<span class='mdl-chip mdl-chip--deletable'> <span class='mdl-chip__text'>${text}</span> <button type='button' class='mdl-chip__action' onclick='document.clearFilter(this, ${num})'> <svg style='width:18px;height:18px' viewBox='0 0 24 24'> <path fill='#ffffff' d='M19,6.41L17.59,5L12,10.59L6.41,5L5,6.41L10.59,12L5,17.59L6.41,19L12,13.41L17.59,19L19,17.59L13.41,12L19,6.41Z' /> </svg> </button> </span>`;
  };

  makeChipWithColor = function(text, color, num) {
    return `<span class='mdl-chip mdl-chip--deletable' style='background-color: ${color}'> <span class='mdl-chip__text'>${text}</span> <button type='button' class='mdl-chip__action' onclick='document.clearFilter(this, ${num})'> <svg style='width:18px;height:18px' viewBox='0 0 24 24'> <path fill='#ffffff' d='M19,6.41L17.59,5L12,10.59L6.41,5L5,6.41L10.59,12L5,17.59L6.41,19L12,13.41L17.59,19L19,17.59L13.41,12L19,6.41Z' /> </svg> </button> </span>`;
  };

  clearFilter = function(self, num) {
    self.parentNode.remove();
    predicates[num] = null;
    return applyPredicates();
  };

  articlePredicate = function(record) {
    var span;
    span = record.getElementsByClassName("plpro-lib-record-article");
    return span.length > 0;
  };

  indexOfArticlePredicate = {
    index: -1,
    processIt: false
  };

  document.stateChanged = function(self) {
    if (!indexOfArticlePredicate.processIt) {
      indexOfArticlePredicate.processIt = true;
      return;
    }
    indexOfArticlePredicate.processIt = false;
    console.log(self);
    if (self.control.checked) {
      predicates.push(articlePredicate);
      indexOfArticlePredicate.index = predicates.length - 1;
    } else {
      predicates[indexOfArticlePredicate.index] = null;
    }
    return applyPredicates();
  };

  applyPredicates = function() {
    var i, l, len, ref, results, searchBox;
    searchBox = element("search-box");
    ref = searchBox.children;
    results = [];
    for (l = 0, len = ref.length; l < len; l++) {
      i = ref[l];
      if (i.className === "plpro-lib-record") {
        i.style.display = "none";
        if (isAll(i)) {
          results.push(i.style.display = "block");
        } else {
          results.push(void 0);
        }
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  document.autorOnClick = function(self) {
    var filterDiv, text;
    text = self.innerText;
    predicates.push(function(record) {
      var j, l, len, ref;
      ref = record.children;
      for (l = 0, len = ref.length; l < len; l++) {
        j = ref[l];
        if (j.className === "plpro-lib-record-autor" && j.innerText === text) {
          return true;
        }
      }
      return false;
    });
    applyPredicates();
    filterDiv = element("filter");
    return filterDiv.innerHTML += " " + makeChip(`Автор: ${self.innerText}`, predicates.length - 1);
  };

  document.filterByType = function(self) {
    var filterDiv;
    predicates.push(function(record) {
      var k;
      k = (record.getElementsByClassName("filetype-tag"))[0];
      if (k.innerText.trim() === self.innerText.trim()) {
        return true;
      }
      return false;
    });
    applyPredicates();
    filterDiv = element("filter");
    if (self.innerText === "pdf") {
      filterDiv.innerHTML += " " + makeChipWithColor("Тип: .pdf", "rgb(231, 47, 47)", predicates.length - 1);
    }
    if (self.innerText === "djvu") {
      filterDiv.innerHTML += " " + makeChipWithColor("Тип: .djvu", "rgb(160, 0, 160)", predicates.length - 1);
    }
    if (self.innerText === "online") {
      return filterDiv.innerHTML += " " + makeChipWithColor("Тип: online", "rgb(112, 112, 112)", predicates.length - 1);
    }
  };

  document.clearFilter = clearFilter;

}).call(this);
